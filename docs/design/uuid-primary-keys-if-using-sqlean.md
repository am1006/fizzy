# UUID Primary Keys with sqlean Extension

This document describes a hypothetical alternative UUID implementation using the sqlean SQLite extension. For Fizzy's actual implementation, see [uuid-primary-keys.md](uuid-primary-keys.md).

---

## Overview

### What is sqlean?

[sqlean](https://github.com/nalgeon/sqlean) is a collection of SQLite extensions that add missing functionality to SQLite, including UUID support. The `uuid` extension provides native UUID generation and manipulation functions directly in SQL.

### Why Consider sqlean?

Fizzy's current approach generates UUIDs in Ruby using `SecureRandom.uuid_v7`. This works excellently for Rails-centric applications. However, sqlean offers an alternative with different tradeoffs:

**Database-level generation:**
- UUIDs generated by the database, not the application
- Works with raw SQL, database triggers, and non-Ruby clients
- SQL-level timestamp extraction from UUIDv7

**Potential drawbacks:**
- Requires extension management per-platform
- Loses base36 URL aesthetics (unless combined with Ruby encoding)
- Adds deployment complexity

---

## Why UUIDs as Primary Keys?

A **primary key** is simply a column that uniquely identifies each row in a table. It doesn't have to be an integer - it can be any data type that guarantees uniqueness.

### Primary Key Options

| Type | Example | Common Use |
|------|---------|------------|
| Integer (auto-increment) | `1, 2, 3, 4...` | Traditional Rails default |
| UUID | `550e8400-e29b-41d4-...` | Distributed systems, security |
| String | `"user_abc123"` | Readable IDs (Stripe, etc.) |
| Composite | `(user_id, post_id)` | Join tables |

### Why Integers Became the Default

Integers were the traditional choice due to historical database optimizations:

```ruby
# Traditional Rails
create_table :cards do |t|  # implicitly creates integer `id`
  t.string :title
end
# Results in: id: 1, 2, 3, 4, 5...
```

**Pros of integers:**
- Small storage (4-8 bytes)
- Fast comparisons
- Simple auto-increment

**Cons of integers:**
- Expose how many records exist (`/users/5` = 5th user)
- Predictable (easy to guess `/users/6`)
- Hard in distributed systems (two servers might create `id: 1000` simultaneously)

### Why Use UUIDs Instead

```ruby
# UUID approach
create_table :cards, id: :uuid do |t|
  t.string :title
end
# Results in: id: "019375e5-7c3a-7b82-8f3d-9a2e1b4c5d6e", ...
```

**Pros of UUIDs:**
- No information leakage (can't guess other IDs)
- Globally unique (can generate anywhere, merge databases safely)
- With UUIDv7: still time-sortable like integers

**Cons of UUIDs:**
- Larger storage (16 bytes vs 4-8 bytes)
- Longer URLs (36 chars with dashes)

### Visual Comparison

```
Integer Primary Key:
┌────────┬─────────────┐
│ id     │ title       │
├────────┼─────────────┤
│ 1      │ First card  │  <- Attacker knows: "only 3 cards exist"
│ 2      │ Second card │  <- Attacker can try: /cards/4, /cards/5...
│ 3      │ Third card  │
└────────┴─────────────┘

UUID Primary Key:
┌──────────────────────────────────────┬─────────────┐
│ id                                   │ title       │
├──────────────────────────────────────┼─────────────┤
│ 019375e5-7c3a-7b82-8f3d-9a2e1b4c5d6e │ First card  │  <- No count revealed
│ 019375e6-1a2b-7c3d-8e4f-0a1b2c3d4e5f │ Second card │  <- Can't guess other IDs
│ 019375e7-5f6a-7b8c-9d0e-1f2a3b4c5d6e │ Third card  │
└──────────────────────────────────────┴─────────────┘
```

### It's Still a Primary Key

The database still enforces the same rules:

```sql
-- SQLite with UUID (using sqlean)
CREATE TABLE cards (
  id BLOB(16) PRIMARY KEY DEFAULT (uuid_blob(uuid7())),  -- Still a primary key!
  title TEXT
);
```

The database guarantees:
- **Uniqueness** - No two rows can have the same `id`
- **Not null** - Every row must have an `id`
- **Indexed** - Fast lookups by `id`

### Common Misconceptions

| Myth | Reality |
|------|---------|
| "Primary keys must be integers" | Primary keys can be any unique value |
| "UUIDs can't be sorted" | UUIDv7 is time-sortable (newer = larger) |
| "UUIDs are random gibberish" | UUIDv7 embeds a timestamp |

---

## sqlean UUID Functions

The sqlean `uuid` extension provides these key functions:

### `uuid7()`

Generates a new UUIDv7 as a 36-character string:

```sql
SELECT uuid7();
-- '019375e5-7c3a-7b82-8f3d-9a2e1b4c5d6e'
```

### `uuid_blob(x)`

Converts a UUID string to a 16-byte binary blob for compact storage:

```sql
SELECT uuid_blob(uuid7());
-- x'019375e57c3a7b828f3d9a2e1b4c5d6e' (16 bytes)
```

### `uuid_str(x)`

Converts a 16-byte blob back to the standard UUID string format:

```sql
SELECT uuid_str(uuid_blob(uuid7()));
-- '019375e5-7c3a-7b82-8f3d-9a2e1b4c5d6e'
```

### `uuid7_timestamp_ms(x)`

Extracts the Unix timestamp (milliseconds) embedded in a UUIDv7:

```sql
SELECT uuid7_timestamp_ms('019375e5-7c3a-7b82-8f3d-9a2e1b4c5d6e');
-- 1735123456789

-- Convert to datetime
SELECT datetime(uuid7_timestamp_ms(id) / 1000, 'unixepoch')
FROM cards
WHERE id = x'...';
-- '2024-12-25 10:30:45'
```

This is particularly powerful for time-based queries without an additional `created_at` column.

---

## Design Comparison

| Aspect | Fizzy's Pure-Ruby Approach | sqlean Approach |
|--------|---------------------------|-----------------|
| **Generation Location** | Ruby (`SecureRandom.uuid_v7`) | Database (`uuid7()`) |
| **String Format** | Base36 (25 chars, URL-friendly) | Standard UUID (36 chars with dashes) |
| **Storage** | `blob(16)` / `binary(16)` | `blob(16)` / `binary(16)` |
| **Schema Default** | Ruby callback in ActiveRecord | SQL `DEFAULT (uuid_blob(uuid7()))` |
| **Timestamp Extraction** | Parse in Ruby | SQL `uuid7_timestamp_ms()` |
| **Raw SQL Inserts** | Must provide ID | Auto-generated by database |
| **Trigger Support** | Triggers cannot generate IDs | Triggers can use `uuid7()` |
| **Multi-Language** | Each language needs generation code | Database handles it |
| **Deployment** | No additional dependencies | Extension per platform |
| **MySQL Support** | Works identically | sqlean is SQLite-only |

---

## Implementation Details

### Schema with Database-Level Defaults

With sqlean, you can define columns with database-generated UUIDs:

```sql
CREATE TABLE cards (
  id BLOB(16) PRIMARY KEY DEFAULT (uuid_blob(uuid7())),
  board_id BLOB(16) NOT NULL,
  title TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Inserts work without specifying ID
INSERT INTO cards (board_id, title) VALUES (x'...', 'New card');
```

In a Rails migration:

```ruby
class CreateCards < ActiveRecord::Migration[8.2]
  def change
    create_table :cards, id: false do |t|
      # Note: Rails doesn't natively support this default syntax
      # You'd need to use raw SQL or a custom column definition
      t.column :id, "BLOB(16) DEFAULT (uuid_blob(uuid7()))", primary_key: true
      t.uuid :board_id, null: false
      t.string :title
      t.timestamps
    end
  end
end
```

Or with raw SQL for clarity:

```ruby
class CreateCards < ActiveRecord::Migration[8.2]
  def up
    execute <<~SQL
      CREATE TABLE cards (
        id BLOB(16) PRIMARY KEY DEFAULT (uuid_blob(uuid7())),
        board_id BLOB(16) NOT NULL,
        title TEXT,
        created_at DATETIME,
        updated_at DATETIME
      );
    SQL
  end
end
```

### Extension Loading in Rails

sqlean extensions must be loaded for each database connection. Configure this in `database.yml` or an initializer:

**Option 1: Using SQLite3 adapter configuration**

```yaml
# config/database.yml
development:
  adapter: sqlite3
  database: storage/development.sqlite3
  extensions:
    - .sqlean/uuid
```

Note: This requires the sqlite3 gem to support extension loading, which depends on your SQLite build.

**Option 2: Connection initializer**

```ruby
# config/initializers/sqlean.rb
if Rails.configuration.database_configuration[Rails.env]["adapter"] == "sqlite3"
  ActiveSupport.on_load(:active_record) do
    ActiveRecord::Base.connection.execute("SELECT load_extension('.sqlean/uuid')")
  end
end
```

**Option 3: Custom connection handler**

```ruby
# config/initializers/sqlean.rb
module SqleanExtensionLoader
  EXTENSIONS = %w[uuid].freeze

  def configure_connection
    super
    load_sqlean_extensions
  end

  private
    def load_sqlean_extensions
      EXTENSIONS.each do |ext|
        extension_path = Rails.root.join(".sqlean", ext)
        raw_execute("SELECT load_extension('#{extension_path}')")
      end
    rescue => e
      Rails.logger.warn("Failed to load sqlean extensions: #{e.message}")
    end
end

ActiveSupport.on_load(:active_record_sqlite3adapter) do
  ActiveRecord::ConnectionAdapters::SQLite3Adapter.prepend(SqleanExtensionLoader)
end
```

### Simpler ActiveRecord Type

With sqlean handling generation, the ActiveRecord type becomes simpler:

```ruby
# lib/rails_ext/active_record_uuid_type.rb
module ActiveRecord
  module Type
    class Uuid < Binary
      # No generation logic needed - database handles it

      def serialize(value)
        return unless value

        # Convert hex string to binary
        hex = value.to_s.delete("-")
        binary = [hex].pack("H*")
        super(binary)
      end

      def deserialize(value)
        return unless value

        # Convert binary to standard UUID format
        hex = value.to_s.unpack1("H*")
        format_as_uuid(hex)
      end

      def cast(value)
        value
      end

      private
        def format_as_uuid(hex)
          # Standard UUID format with dashes
          "#{hex[0,8]}-#{hex[8,4]}-#{hex[12,4]}-#{hex[16,4]}-#{hex[20,12]}"
        end
    end
  end
end
```

Note: This loses base36 encoding. See "Hybrid Approach" below for combining sqlean with base36.

### SQL-Level Timestamp Queries

One of sqlean's unique advantages is extracting timestamps directly in SQL:

```sql
-- Find cards created in the last hour
SELECT * FROM cards
WHERE uuid7_timestamp_ms(id) > (strftime('%s', 'now') - 3600) * 1000;

-- Get creation time without a created_at column
SELECT
  uuid_str(id) as id,
  datetime(uuid7_timestamp_ms(id) / 1000, 'unixepoch') as created_at,
  title
FROM cards;

-- Order by embedded timestamp (though ordering by id blob works too)
SELECT * FROM cards ORDER BY uuid7_timestamp_ms(id) DESC;
```

In ActiveRecord with Arel:

```ruby
class Card < ApplicationRecord
  scope :created_after, ->(time) {
    ms = (time.to_f * 1000).to_i
    where("uuid7_timestamp_ms(id) > ?", ms)
  }

  scope :created_between, ->(start_time, end_time) {
    start_ms = (start_time.to_f * 1000).to_i
    end_ms = (end_time.to_f * 1000).to_i
    where("uuid7_timestamp_ms(id) BETWEEN ? AND ?", start_ms, end_ms)
  }
end

# Usage
Card.created_after(1.hour.ago)
Card.created_between(1.day.ago, Time.current)
```

---

## Tradeoffs

### When sqlean Makes Sense

**Raw SQL usage:**
If you frequently write raw SQL outside of ActiveRecord (database scripts, data migrations, admin tools), sqlean means you don't need to generate UUIDs in Ruby first.

```sql
-- Works with sqlean
INSERT INTO cards (board_id, title) VALUES (uuid_blob(uuid7()), 'My card');

-- Without sqlean, you must generate the UUID elsewhere first
```

**SQL-level timestamp queries:**
When you need to query by creation time and want to use the embedded UUIDv7 timestamp:

```sql
-- Find all records created today, using only the ID
SELECT * FROM events
WHERE date(uuid7_timestamp_ms(id) / 1000, 'unixepoch') = date('now');
```

**Database triggers:**
If you use triggers that need to generate UUIDs:

```sql
CREATE TRIGGER audit_log AFTER UPDATE ON cards
BEGIN
  INSERT INTO audit_entries (id, card_id, action)
  VALUES (uuid_blob(uuid7()), NEW.id, 'updated');
END;
```

**Multi-language stacks:**
When multiple languages/services access the same database, having the database generate UUIDs ensures consistency without coordinating generation logic.

### When Pure-Ruby Wins

**Rails-centric applications:**
If everything goes through ActiveRecord, Ruby-based generation is simpler with no extension dependencies.

**Multiple databases:**
Fizzy uses both MySQL (production) and SQLite (development/testing). sqlean is SQLite-only, so you'd need different strategies per database. The pure-Ruby approach works identically everywhere.

**Deployment simplicity:**
No need to manage platform-specific binaries or worry about extension loading.

**URL aesthetics (base36):**
The pure-Ruby approach enables base36 encoding for shorter, prettier URLs:

```
# Pure-Ruby base36
/cards/01jcqzx8h0000000000000000

# Standard UUID format
/cards/019375e5-7c3a-7b82-8f3d-9a2e1b4c5d6e
```

**Fixture determinism:**
Fizzy's fixture system generates deterministic, time-ordered UUIDs for testing. This Ruby-level control is harder to replicate with database generation.

---

## Hybrid Approach

You can combine sqlean's database-level generation with Ruby-level base36 encoding for URLs:

### Schema

```sql
CREATE TABLE cards (
  id BLOB(16) PRIMARY KEY DEFAULT (uuid_blob(uuid7())),
  -- ...
);
```

### ActiveRecord Type with Base36

```ruby
module ActiveRecord
  module Type
    class Uuid < Binary
      BASE36_LENGTH = 25

      class << self
        # No generate method needed - database handles it

        def hex_to_base36(hex)
          hex.to_i(16).to_s(36).rjust(BASE36_LENGTH, "0")
        end

        def base36_to_hex(base36)
          base36.to_s.to_i(36).to_s(16).rjust(32, "0")
        end
      end

      def serialize(value)
        return unless value

        # Accept both base36 and standard UUID formats
        hex = if value.include?("-")
          value.delete("-")
        else
          self.class.base36_to_hex(value)
        end

        binary = [hex].pack("H*")
        super(binary)
      end

      def deserialize(value)
        return unless value

        hex = value.to_s.unpack1("H*")
        self.class.hex_to_base36(hex)  # Return base36 for URL-friendliness
      end

      def cast(value)
        value
      end
    end
  end
end
```

### Handling Database-Generated IDs

When the database generates the ID, you need to reload to get the base36 version:

```ruby
card = Card.create!(title: "New card")
card.reload  # Fetch the database-generated ID
card.id      # => "01jcqzx8h0000000000000000" (base36)
```

Or configure `returning` in PostgreSQL/modern SQLite to get the ID immediately.

---

## Extension Management

### Loading Extensions Per-Connection

SQLite extensions must be loaded for each connection. This is critical in multi-threaded environments:

```ruby
# config/initializers/sqlean.rb
module SqleanConnectionSetup
  def configure_connection
    super
    enable_load_extension
    load_uuid_extension
  end

  private
    def enable_load_extension
      # Enable extension loading (disabled by default for security)
      raw_execute("SELECT 1")  # Ensure connection is established
      @raw_connection.enable_load_extension(true)
    end

    def load_uuid_extension
      raw_execute("SELECT load_extension(?)", [sqlean_extension_path("uuid")])
    rescue SQLite3::Exception => e
      raise "Failed to load sqlean uuid extension: #{e.message}"
    end

    def sqlean_extension_path(name)
      base = Rails.root.join(".sqlean")

      # Platform-specific extension
      case RUBY_PLATFORM
      when /darwin/
        base.join("#{name}.dylib")
      when /linux/
        base.join("#{name}.so")
      when /mingw|mswin/
        base.join("#{name}.dll")
      else
        base.join(name)
      end.to_s
    end
end

ActiveSupport.on_load(:active_record_sqlite3adapter) do
  ActiveRecord::ConnectionAdapters::SQLite3Adapter.prepend(SqleanConnectionSetup)
end
```

### Platform-Specific Binaries

sqlean provides pre-built binaries for common platforms. Structure your project:

```
.sqlean/
  uuid.dylib      # macOS (arm64 and x86_64 universal)
  uuid.so         # Linux x86_64
  uuid-arm64.so   # Linux ARM64
  uuid.dll        # Windows
```

**Download script:**

```bash
#!/bin/bash
# bin/setup-sqlean

SQLEAN_VERSION="0.27.1"
SQLEAN_DIR=".sqlean"

mkdir -p "$SQLEAN_DIR"

case "$(uname -s)-$(uname -m)" in
  Darwin-*)
    curl -L "https://github.com/nalgeon/sqlean/releases/download/${SQLEAN_VERSION}/sqlean-macos-arm64.zip" -o /tmp/sqlean.zip
    ;;
  Linux-x86_64)
    curl -L "https://github.com/nalgeon/sqlean/releases/download/${SQLEAN_VERSION}/sqlean-linux-x86.zip" -o /tmp/sqlean.zip
    ;;
  Linux-aarch64)
    curl -L "https://github.com/nalgeon/sqlean/releases/download/${SQLEAN_VERSION}/sqlean-linux-arm64.zip" -o /tmp/sqlean.zip
    ;;
esac

unzip -o /tmp/sqlean.zip -d "$SQLEAN_DIR"
rm /tmp/sqlean.zip
```

### Version Management

Track sqlean version for reproducible builds:

```ruby
# .sqlean-version
0.27.1
```

```ruby
# config/initializers/sqlean.rb
SQLEAN_VERSION = File.read(Rails.root.join(".sqlean-version")).strip

def verify_sqlean_version
  result = ActiveRecord::Base.connection.execute(
    "SELECT sqlean_version()"
  ).first

  unless result["sqlean_version()"] == SQLEAN_VERSION
    Rails.logger.warn("sqlean version mismatch: expected #{SQLEAN_VERSION}")
  end
end
```

### Different Extensions per Database

When using MySQL in production and SQLite in development:

```ruby
# config/initializers/uuid_extensions.rb

case ActiveRecord::Base.connection.adapter_name
when "SQLite"
  # Load sqlean for SQLite
  require_relative "sqlean_loader"
  SqleanLoader.load_extensions

when "Trilogy", "Mysql2"
  # MySQL doesn't need sqlean - UUIDs generated in Ruby
  # or use MySQL's UUID_TO_BIN() / BIN_TO_UUID() for similar functionality
end
```

For MySQL, note that MySQL 8.0+ has built-in UUID functions:

```sql
-- MySQL equivalent (not identical to sqlean)
SELECT UUID_TO_BIN(UUID(), TRUE);  -- Generates UUID and converts to binary
SELECT BIN_TO_UUID(id, TRUE) FROM cards;  -- Converts binary back to string
```

However, MySQL's `UUID()` generates UUIDv1 (not v7), so timestamp ordering differs.

---

## Related Documents

- [uuid-primary-keys.md](uuid-primary-keys.md) - Fizzy's actual pure-Ruby implementation
- [sqlean GitHub](https://github.com/nalgeon/sqlean) - Official sqlean repository
- [RFC 9562](https://www.rfc-editor.org/rfc/rfc9562.html) - UUIDv7 specification

---

## Summary

The sqlean approach is a valid alternative to Fizzy's pure-Ruby UUID implementation, offering database-level generation and SQL-native timestamp queries. However, for a Rails-centric application like Fizzy that uses multiple databases (MySQL + SQLite) and values URL aesthetics (base36), the pure-Ruby approach provides better consistency and simpler deployment.

Consider sqlean when:
- You need database triggers to generate UUIDs
- Multiple non-Ruby services access your SQLite database
- You want to query by UUIDv7 timestamps in SQL
- You're building an SQLite-only application

Stick with pure-Ruby when:
- You're Rails-centric with all access through ActiveRecord
- You use multiple database backends
- You want URL-friendly base36 encoding
- You need deterministic fixture UUID generation
